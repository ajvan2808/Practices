{
  "start_timestamp": "2022-04-15T10:30:42Z",
  "end_timestamp": "2023-04-17T10:30:42Z",
  "smart_contracts": [
    {
      "code": "api = \"3.9.0\"\nversion = \"1.0.0\"\ndisplay_name = \"Saving Account Demo\"\nsummary = \"Saving account demo - Practice with Ops smart contract version\"\ntside = Tside.LIABILITY\ndenomination = \"USD\"\ninternal_account = \"1\"\n\nACCRUED_INTEREST_PAYABLE = \"ACCRUED_INTEREST_PAYABLE\"\nACCRUED_INTEREST_RECEIVABLE = \"ACCRUED_INTEREST_RECEIVABLE\"\n\nglobal_parameters = [\n    \"sa_interest_rate\",\n    \"sa_penalty_interest_rate\",\n    \"sa_cash_ops_fee\",\n]\n\nsupported_denomination = [\"USD\"]\nevent_types = [\n    EventType(\n        name=\"ACCRUE_INTEREST\",\n        scheduler_tag_ids=[\"SAVING_ACCOUNT_ACCRUE_INTEREST\"]\n    ),\n    EventType(\n        name=\"APPLY_ACCRUED_INTEREST\",\n        scheduler_tag_ids=[\"SAVING_ACCOUNT_APPLY_DEPOSIT_INTEREST\"]\n    ),\n    EventType(\n        name=\"APPLY_ACCRUED_PENALTY_INTEREST\",\n        scheduler_tag_ids=[\"SAVING_ACCOUNT_APPLY_ACCRUED_PENALTY_INTEREST\"]\n    ),\n]\n\nparameters = [\n    Parameter(\n        name=\"interest_accrual_days_in_year\",\n        shape=UnionShape(\n            UnionItem(key=\"actual\", display_name=\"Actual\"),\n            UnionItem(key=\"365\", display_name=\"365\"),\n            UnionItem(key=\"360\", display_name=\"360\")\n        ),\n        level=Level.TEMPLATE,\n        description=\"The days in the year for interest accrual calculation.\"\n                    ' Valid values are \"actual\", \"365\", \"360\"',\n        display_name=\"Interest accrual days in year\",\n        default_value=UnionItemValue(key=\"actual\")\n    )\n]\n\n\n@requires(parameters=False)\ndef execution_schedules():\n    return [\n        (\n            'ACCRUE_INTEREST', {\n                'hour': '23',\n                'minute': '59',\n                'second': '59',\n            }\n        ),\n        (\n            'APPLY_ACCRUED_INTEREST', {\n                'day': '1',\n                'hour': '1',\n                'minute': '0',\n                'second': '0',\n            }\n        ),\n        (\n            'APPLY_ACCRUED_PENALTY_INTEREST', {\n                'day': '1',\n                'hour': '1',\n                'minute': '0',\n                'second': '0',\n            }\n        ),\n    ]\n\n\n@requires(event_type='ACCRUE_INTEREST', parameters=True, balances='1 day')\n@requires(event_type='APPLY_ACCRUED_INTEREST', parameters=True, balances='1 day')\n@requires(event_type='APPLY_ACCRUED_PENALTY_INTEREST', parameters=True, balances='1 day')\ndef scheduled_code(event_type, effective_date):\n    if event_type == 'ACCRUE_INTEREST':\n        _accrued_interest(vault, effective_date)\n    elif event_type == 'APPLY_ACCRUED_INTEREST':\n        _apply_accrued_interest(vault, effective_date)\n    elif event_type == 'APPLY_ACCRUED_PENALTY_INTEREST':\n        _apply_accrued_penalty_fee(vault, effective_date, penalty=True)\n\n\n# Get the value of the latest balance when we receive the posting\n@requires(parameters=True, balances=\"latest live\", postings=\"1 day\")\ndef pre_posting_code(postings, effective_date):\n    if any(post.denomination != denomination for post in postings):\n        raise Rejected(\"Cannot make transactions in given denomination; \"\n                       f\"transactions must be in {denomination}\",\n                       reason_code=RejectedReason.WRONG_DENOMINATION,)\n\n    balances = vault.get_balance_timeseries().latest()\n    available_balance = _get_balancce(balances, denomination)\n    for post in postings:\n        amount = post.amount\n        if post.instruction_details.get(\"ops_type\") == \"CASH\":\n            amount += _calculate_cash_ops_fee(vault, amount)\n        if (\n                not post.credit\n                and amount > available_balance\n                and post.instruction_details.get(\"ops_type\") != \"INTEREST\"\n        ):\n            raise Rejected(\"Insufficient fund for transaction.\",\n                           reason_code=RejectedReason.INSUFFICIENT_FUNDS,)\n\n\n@requires(parameters=True, balances='latest live', postings='1 day')\ndef post_posting_code(postings, effective_date):\n    for post in postings:\n        if post.instruction_details.get(\"ops_type\") == 'CASH':\n            _apply_cash_ops_fee(vault, effective_date, post.amount)\n\n\ndef _apply_cash_ops_fee(vault, effective_date, amount):\n    ops_fee = _calculate_cash_ops_fee(vault, amount)\n    if ops_fee:\n        instructions = vault.make_internal_transfer_instructions(\n            amount=ops_fee,\n            denomination=denomination,\n            from_account_id=vault.account_id,\n            from_account_address=DEFAULT_ADDRESS,\n            to_account_id=internal_account,\n            to_account_address=DEFAULT_ADDRESS,\n            asset=DEFAULT_ASSET,\n            client_transaction_id='CASH_OPS_FEE_{}'.format(\n                vault.get_hook_execution_id()\n            ),\n            instruction_details={\n                'description': 'Cash operation fee charged'\n            },\n            pics=[],\n        )\n        vault.instruct_posting_batch(\n            posting_instructions=instructions,\n            effective_date=effective_date,\n            client_batch_id='BATCH_{}_CASH_OPS_FEE'.format(\n                vault.get_hook_execution_id()\n            )\n        )\n\n\ndef _calculate_cash_ops_fee(vault, amount):\n    ops_fee_rate = ault.get_parameter_timeseries(name='sa_cash_ops_fee').latest()\n    return _precision_fulfilment(ops_fee_rate * amount) if ops_fee_rate > 0 else Decimal('0')\n\n\ndef _get_balance(balances, denomination, address=DEFAULT_ADDRESS, asset=DEFAULT_ASSET):\n    return (\n        balances[(address, asset, denomination, Phase.COMMITED)].net\n        + balances[(address, asset, denomination, Phase.PENDING_OUT)].net\n    )\n\n\ndef _accrue_interest(vault, effective_date):\n    balances = vault.get_balance_timeseries().at(timestamp=effective_date)\n    effective_balance = balances[(DEFAULT_ADDRESS, DEFAULT_ASSET, denomination, Phase.COMMITED)].net\n    if effective_balance >= 0:\n        interest_rate = vault.get_parameter_timeseries(name='sa_interest_rate').at(timestamp=effective_date)\n        days_in_year = _get_parameter(name='interest_accrual_days_in_year', vault=vault).key\n        daily_rate = _yearly_to_daily_rate(days_in_year, effective_date.year, interest_rate)\n        daily_rate_percent = daily_rate * 100\n        amount_to_accrue = _precision_accrual(effective_balance * daily_rate)\n        from_account_id = internal_account\n        from_account_address = DEFAULT_ADDRESS\n        to_account_id = vault.account_id\n        to_account_address = ACCRUED_INTEREST_PAYABLE\n    else:\n        interest_rate = vault.get_parameter_timeseries(name='sa_penalty_interest_rate').at(timestamp=effective_date)\n        daily_rate = _yearly_to_daily_rate(\"actual\", interest_rate, effective_date.year)\n        daily_rate_percent = daily_rate * 100\n        amount_to_accrue = _precision_accrual(abs(effective_balance * daily_rate))\n        from_account_id = vault.account_id\n        from_account_address = ACCRUED_INTEREST_RECEIVABLE\n        to_account_id = internal_account\n        to_account_address = DEFAULT_ADDRESS\n    if amount_to_accrue > 0:\n        posting_instruction = vault.make_internal_transfer_instructions(\n            amount=amount_to_accrue,\n            denomination=denomination,\n            client_transaction_id=f\"ACCRUE_INTEREST_{vault.get_hook_execution_id()}\",\n            from_account_id=from_account_id,\n            from_account_address=from_account_address,\n            to_account_id=to_account_id,\n            to_account_address=to_account_address,\n            instruction_details={\n                'description': 'Daily interest accrued at %0.5f%% on balance of %0.2f' %(daily_rate_percent, effective_balance)\n            },\n            asset=DEFAULT_ASSET,\n        )\n        vault.instruct_posting_batch(\n            posting_instructions=posting_instruction,\n            effective_date=effective_date,\n        )\n\n\ndef _apply_accrued_interest(vault, effective_date, penalty=False):\n    latest_bal_by_address = vault.get_balance_timeseries().at(timestamp=effective_date)\n    accrued_payable = latest_bal_by_address[(ACCRUED_INTEREST_PAYABLE, DEFAULT_ASSET, denomination, Phase.COMMITED)].net\n    accrued_receivable = latest_bal_by_address[(ACCRUED_INTEREST_RECEIVABLE, DEFAULT_ASSET, denomination, Phase.COMMITED)].net\n    amount_to_be_paid = _precision_fulfilment(accrued_payable)\n    amount_to_be_charged = _precision_fulfilment(accrued_receivable)\n    instructions = []\n    if not penalty and amount_to_be_paid > Decimal(\"0.00\"):\n        instructions.extend(vault.make_internal_transfer_instructions(\n            amount=amount_to_be_paid,\n            denomination=denomination,\n            from_account_id=vault.account_id,\n            from_account_address=ACCRUED_INTEREST_PAYABLE,\n            to_account_id=vault.account_id,\n            to_account_address=DEFAULT_ADDRESS,\n            asset=DEFAULT_ASSET,\n            client_transaction_id=f\"APPLY_ACCRUED_INTEREST_{vault.get_hook_execution_id()}\",\n            instruction_details={\n                \"description\": \"Accrued Interest Applied\",\n                \"event\": \"APPLY_ACCRUED_INTEREST\",\n                \"ops_type\": \"INTERESTS\",\n            }\n        ))\n        fulfilment_remainder = accrued_payable + amount_to_be_paid\n        if fulfilment_remainder != 0:\n            _clear_fractional_amount(vault, fulfilment_remainder, 'PAYABLE', instructions)\n\n    elif penalty and amount_to_be_charged > Decimal(\"0.00\"):\n        instructions.extend(vault.make_internal_transfer_instructions(\n            amount=amount_to_be_charged,\n            denomination=denomination,\n            from_account_id=vault.account_id,\n            from_account_address=DEFAULT_ADDRESS,\n            to_account_id=vault.account_id,\n            to_account_address=ACCRUED_INTEREST_RECEIVABLE,\n            asset=DEFAULT_ASSET,\n            client_transaction_id=f\"APPLY_ACCRUED_PENALTY_INTEREST_{vault.get_hook_execution_id()}\",\n            instruction_details={\n                \"description\": \"Accrued Penalty Interest Applied\",\n                \"event\": \"APPLY__ACCRUED_PENALTY_INTEREST\",\n                \"ops_type\": \"INTERESTS\",\n            }\n        ))\n        fulfilment_remainder = accrued_receivable + amount_to_be_charged\n        if fulfilment_remainder != 0:\n            _clear_fractional_amount(vault, fulfilment_remainder, 'RECEIVABLE', instructions)\n\n    client_batch_prefix = \"APPLY_ACCRUED_PENALTY_INTEREST\" if penalty else \"APPLY_ACCRUED_INTEREST\"\n    if instructions:\n        vault.instruct_posting_batch(\n            posting_instructions=instructions,\n            effective_date=effective_date,\n            client_batch_id=f\"{client_batch_prefix}_{vault.get_hook_execution_id()}\",\n        )\n\n\ndef _clear_fractional_amount(vault, remainder_amount, remainder_type, instruction):\n    if remainder_amount > 0:\n        from_account_id = vault.account_id,\n        from_account_address = f\"ACCRUED_INTEREST_{remainder_type}\",\n        to_account_id = internal_account,\n        to_account_address = DEFAULT_ADDRESS,\n\n    elif remainder_amount < 0:\n        from_account_id = internal_account,\n        from_account_address = DEFAULT_ADDRESS\n        to_account_id = vault.account_id,\n        to_account_address = f\"ACCRUED_INTEREST_{remainder_type}\",\n\n    if abs(remainder_amount) > 0:\n        instruction.extend(\n            vault.make_internal_transfer_instructions(\n                amount=abs(remainder_amount),\n                denomination=denomination,\n                from_accoint_id=from_account_id,\n                from_account_address=from_account_address,\n                to_account_id=to_account_id,\n                to_account_address=to_account_address,\n                asset=DEFAULT_ASSET,\n                client_transaction_id=f\"CLEAR_RESIDUAL_FRACTIONAL_{remainder_type}_ACCRUAL_\"\n                                      f\"AMOUNTS_{vault.get_hook_execution_id()}\",\n                instruction_details={\n                    \"description\": f\"Clear residual fractional amounts from \"\n                                   f\"{remainder_type.lower()} accrual addresses due to rounding \",\n                    \"event\": \"APPLY_ACCRUED_INTEREST\" if remainder_type == 'PAYABLE' else \"APPLY_ACCRUED_PENALTY_INTEREST\",\n                },\n            )\n        )\n\n\ndef _yearly_to_daily_rate(days_in_year, year, yearly_rate):\n    allowed_values = ['actual', '365', '360']\n    if days_in_year in allowed_values:\n        if days_in_year == 'actual':\n            days_in_year = 366 if _is_leap_year(year) else 365\n        else:\n            days_in_year = Decimal(days_in_year)\n        return yearly_rate / days_in_year\n\n\ndef _is_leap_year(year):\n    if year % 400 == 0:\n        return True\n    elif year % 100 == 0:\n        return False\n    elif year % 4 == 0:\n        return True\n    else:\n        return False\n\n\ndef _get_parameter(vault, name, at=None, is_json=False, optional=False, default_value=None):\n    if at:\n        parameter = vault.get_parameter_timeseries(name=name).at(timestamp=at)\n    else:\n        parameter = vault.get_parameter_timeseries(name=name).latest()\n    if optional:\n        parameter = parameter.value if parameter.is_set() else default_value\n    if is_json:\n        parameter = json_loads(parameter)\n    return parameter\n\n\ndef _precision_accrual(amount):\n    return amount.copy_abs().quantize(Decimal('.00001'), rounding=ROUND_HALF_UP)\n\n\ndef _precision_fulfilment(amount):\n    return amount.copy_abs().quantize(Decimal('.01'), rounding=ROUND_HALF_UP)\n",
      "smart_contract_param_vals": {
        "interest_accrual_days_in_year": "365"
      },
      "smart_contract_version_id": "1"
    }
  ],
  "supervisor_contracts": [],
  "instructions": [
    {
      "timestamp": "2022-04-15T10:30:42Z",
      "create_account": {
        "id": "SavingAccount",
        "product_version_id": "1",
        "instance_param_vals": {}
      }
    }
  ]
}